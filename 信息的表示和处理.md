信息的表示和处理
===

三种重要的数字表示：**无符号**编码基于传统的二进制表示法，表示大于或者等于0的数字。
**补码**编码是表示有符号正数的最常见的方式，有符号正数就是可以为正或者为负的数字。
**浮点数**编码是表示实数的科学记数法的以2为基数的版本。

## 信息存储

机器级的程序将存储器视为一个非常大的字节数组，称为**虚拟存储器**，存储器的每个字
节都由一个唯一的数字来标识，称为地址，所有可能地址的集合称为**虚拟地址空间**。

#### 十六进制表示法

以十六进制数来表示位模式。

当值x是2的非负整数n次幂时，我们可以很容易地将x携程十六进制形式，只要记住x的二进
制表示就是1后面跟n个0。十六进制数字0代表4个二进制0。所以当n表示成i + 4j的形式，
其中，0 <= i <= 3，可以把x写成开头的十六进制数字为1(i = 0), 2(i = 1), 4(i = 2),
或者8(i = 3)，后面跟随着j个十六进制的0。

#### 字

字长指名整数和指针数据的标称大小。

#### 数据大小

#### 寻址和字节顺序

在几乎所有机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最
小的地址。

#### 表示字符串

在使用ASCII码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。
因此，文本数据比二进制数据具有更强的平台独立性。

#### 布尔代数简介

将逻辑值TRUE和FALSE编码为二进制0和1，以研究逻辑推理的基本原则。

**位向量**就是有固定长度为w，由0和1组成的串。

#### C语言中的位级运算

确定一个位级表达式最好的方法，就是将十六进制的参数扩展成二进制表示并执行二进制运
算，然后再转回十六进制。

位级运算的一个常见的用法就是实现**掩码**运算，这里掩码是一个位模式，表示从一个字
中选出的位的集合。

#### C语言中的逻辑运算

#### C语言中的移位运算

C语言提供了一组**移位**运算，以便向左或者向右移位模式。

## 整数表示

用位来表示编码整数的两种不同的方式：一种只能表示非负数，而另一种能表示负数、0和正
数。

#### 整形数据表示

#### 无符号数的编码

函数B2Uw能够被定义为一个映射B2Uw : { 0, 1}w -> { 0, ..., 2w -1 }

#### 补码编码

最常见的有符号数的计算机表示方式就是**补码**形式。

#### 有符号数和无符号数之间的相互转换

C语言中，强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。

函数T2U的一般行为是，当将一个有符号数映射为它的相应的无符号数时，负数就被转换成了
大的正数，而非负数则保持不变。

函数U2T的一般行为是，当将一个无符号数映射为它的相应的有符号数时，对于在0 <= x <
2<sup>w-1</sup>，将保留数字的原值。对于大的数（>= 2<sup>w-1</sup>），数字将被被
转换成一个负数。

总结一下无符号与补码之间相互转换的结果。对于在0 <= x < 2<sup>w-1</sup>范围之内的
值x而言，T2U<sub>w</sub>(x) = x，U2T<sub>w</sub>(x) = x。也就是说，在这个范围内
的数字有相同的无符号和补码表示。对于这个范围以外的数值，转换需要加上或者减去2<sup>
w</sup>。

#### 扩展一个数字的位表示

将一个无符号数转化为一个更大的数据类型时，只需要简单地在表示的开头添加0，这种运算
被称为**零扩展**。将一个补码数字转换为一个更大的数据类型可以执行**符号扩展**，规
则是在表示中添加最高有效位的值的副本。
